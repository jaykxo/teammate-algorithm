name: Auto Assign, Close or Merge PR

on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - reopened
  pull_request_review:
    types:
      - submitted

jobs:
  manage-pr:
    runs-on: ubuntu-latest
    steps:

      # 1️⃣ PR 열릴 때 랜덤 리뷰어 지정
      - name: Assign 2 random reviewers
        id: assign
        uses: actions/github-script@v7
        with:
          script: |
            const githubPkg = require('@actions/github');
            const octokitAssign = new githubPkg.getOctokit(process.env.ORG_ACCESS_TOKEN);

            const org = githubPkg.context.repo.owner;
            let members = [];
            let page = 1;

            while(true){
              const { data } = await octokitAssign.rest.orgs.listMembers({
                org,
                per_page: 100,
                page
              });
              if(data.length === 0) break;
              members = members.concat(data.map(u => u.login));
              page++;
            }

            // PR 작성자 제외
            const author = githubPkg.context.payload.pull_request.user.login;
            members = members.filter(u => u !== author);

            // 랜덤 2명 선택
            const shuffled = members.sort(() => 0.5 - Math.random());
            const reviewers = shuffled.slice(0, 2);

            // 리뷰어 지정
            await octokitAssign.rest.pulls.requestReviewers({
              owner: githubPkg.context.repo.owner,
              repo: githubPkg.context.repo.repo,
              pull_number: githubPkg.context.payload.pull_request.number,
              reviewers
            });

            console.log("Assigned reviewers:", reviewers);
            return reviewers.join(",");

        env:
          ORG_ACCESS_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      # 2️⃣ 리뷰 제출 감지 후 Close / Merge 처리
      - name: Check reviews and act
        uses: actions/github-script@v7
        with:
          script: |
            const githubPkg = require('@actions/github');
            const octokitReview = new githubPkg.getOctokit(process.env.ORG_ACCESS_TOKEN);

            const pr_number = githubPkg.context.payload.pull_request.number;
            const reviewers = steps.assign.outputs.result.split(",");

            const { data: reviews } = await octokitReview.rest.pulls.listReviews({
              owner: githubPkg.context.repo.owner,
              repo: githubPkg.context.repo.repo,
              pull_number: pr_number
            });

            // 지정된 리뷰어 상태 확인
            const reviewMap = {};
            reviewers.forEach(r => reviewMap[r] = null);

            reviews.forEach(r => {
              if (reviewMap.hasOwnProperty(r.user.login)) {
                reviewMap[r.user.login] = r.state;
              }
            });

            console.log("Review map:", reviewMap);

            // 누군가 변경 요청 시 PR 자동 Close
            if (Object.values(reviewMap).includes("CHANGES_REQUESTED")) {
              await octokitReview.rest.issues.createComment({
                owner: githubPkg.context.repo.owner,
                repo: githubPkg.context.repo.repo,
                issue_number: pr_number,
                body: `⚠️ PR 자동 반려: 지정된 리뷰어 중 누군가 변경 요청을 했습니다.`
              });
              await octokitReview.rest.pulls.update({
                owner: githubPkg.context.repo.owner,
                repo: githubPkg.context.repo.repo,
                pull_number: pr_number,
                state: "closed"
              });
              console.log("PR closed due to changes requested.");
              return;
            }

            // 모든 리뷰어가 Approve 했으면 자동 Merge
            const allApproved = Object.values(reviewMap).every(s => s === "APPROVED");
            if (allApproved) {
              await octokitReview.rest.pulls.merge({
                owner: githubPkg.context.repo.owner,
                repo: githubPkg.context.repo.repo,
                pull_number: pr_number
              });
              console.log("PR auto merged.");
            } else {
              console.log("Waiting for all reviewers to approve.");
            }

        env:
          ORG_ACCESS_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
